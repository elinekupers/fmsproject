function I = ecogSimulate(t, rate, synapseFunc, rate2, synapseFunc2,...
    alpha, tau)
% Neural simulation of ECoG signal.
%  Adapted from Miller, Sorenson, Ojemann, Nijs, PLOS Compuational Biology, 2009
%
% I = ecogSimulate(t, rate, synapseFunc, rate2, synapseFunc2, alpha, tau))
%
% We simulate the transmembrane current, I, generated from events at two
% populations of synapses. Each population receives incoming spikes
% generated by a Poisson process. The Poisson rate can be a constant for
% each of the populations or it can be time varying. Spikes (delta
% functions) at each synapse are convolved with an exponentially decaying
% post-synaptic current (time constant tau). The dendrite is treated as a
% leaky integrator, which sums these currents and leaks with time constant
% alpha. If the two populations are the same (each a mixture of positive
% and negative synpapes) and the spike rate is constant and the time
% constants are the default values, than the simulation is the same as
% Miller et al (2009), and can produces a spectrum that is approximately
% 1/f^n, which can shift up or down depending on the spike rate. Other
% effects, such as a stimulus-locked evoked response, can be achieved by
% controlling the distribution of synapses, by varying the Poisson rate
% over time, or by changing the time constants.
%
% 
%
% Inputs:
%   t: time vector (seconds). If negative numbers are included, these will
%      be used to let the network settle and will be clipped from the
%      output, I.
%       [default: t = .001:.001:1] 
%   rate: Poisson rate for first synaptic population (inputs per second). 
%      Can be a scalar or a vector.
%       [default: rate = 1]
%   synapseFunc: function handle used to create synapse weights for first
%      synaptic population
%       [default: synapseFunc = @(x) zeromean(2*rand(x,1)-1)]
%   rate2: Poisson rate for second population. Can be a scalar or vector.
%       [default: rate2 = rate]
%   synapseFunc2: function handle used to create synapse weights for second
%      synaptic population
%       [default: synapseFunc2 = @(x) -synapseFunc(x)]
%  alpha: time constant of dendritic integration (s)
%       [default: alpha = 0.100 % from Miller et al]
%  tau: time constant for post-synaptic current (s)
%       [default: tau = 0.0023 % from Miller et al]
%
% Output
%   I: vector of transmembrane current. The ECoG signal is assumed to be
%           proportional to this vector. If time vector includes negative
%           values, then the corresponding entries in I are removed.
%
% Example 1: Generate baseline signal and broadband elevation:
%   t = .001:.001:1;
%   I1 = ecogSimulate(t, 15);
%   I2 = ecogSimulate(t, 60);
%   figure
%   loglog(0:length(t)-1, abs(fft(I1)), 0:length(t)-1, abs(fft(I2)))
%   set(gca, 'XLim', [1 150]); legend({'off', 'on'})
%
% Example 2: Generate a baseline signal and a stimulus-locked response
%   t = .001:.001:1;
%   I1 = ecogSimulate(t, 15, [], 10, @(x) rand(x,1));
%   I2 = ecogSimulate(t, 15, [], 10*(1+sin(t*2*pi*10)), @(x) rand(x,1));
%   figure
%   loglog(0:length(t)-1, abs(fft(I1)), 0:length(t)-1, abs(fft(I2)))
%   set(gca, 'XLim', [1 150]); legend({'off', 'on'})
  
%% Check Inputs
if ~exist('t', 'var')     || isempty(t),     t = .001:.001:1;  end

if ~exist('rate', 'var')  || isempty(rate),  rate = 1;         end

if ~exist('rate2', 'var') || isempty(rate2), rate2 = rate;     end

if ~exist('synapseFunc', 'var') || isempty(synapseFunc) 
    % default is distribution centered on 0 with range [-1 1]
    synapseFunc = @(x) zeromean(2*rand(x,1)-1);
end

if ~exist('synapseFunc2', 'var') || isempty(synapseFunc2) 
    synapseFunc2 = @(x) -synapseFunc(x);
end

% Time constant of leakage current through dendrictic membrane 
%   Default value from Miller et al, 2009.
%   See also Koch et al, (1996, CerCortex).
if ~exist('alpha', 'var') || isempty(alpha), alpha =0.100; end

% time constant of decaying, post-synaptic current
%   Default value from Miller et al, 2009.
if ~exist('tau', 'var') || isempty(tau), tau =0.0023; end


%% Derived variables
% number of samples in our signal
nt = length(t);

% step size in ms
dt  = median(diff(t));

%% Constants

% we will simulate PSPs at many synapses
numSynapses = 1000; 

%% Spike rates
% convert spike rate from spikes per second to spikes per sample
rate  = rate  * dt;
rate2 = rate2 * dt;

% The rate needs to be a matrix num_time_points x num_synapses. If the rate
% is a scalar, it needs to be expanded in two dimensions. If the rate is a
% vector (ie time-varying), it needs to be expanded only for the number of
% synapses.

% Population 1
if numel(rate) == 1,  n = nt; else n = 1; end
rate  = repmat(rate(:),  n, numSynapses/2);

% Population 2
if numel(rate2) == 1,  n = nt; else n = 1; end
rate2 = repmat(rate2(:), n, numSynapses/2);

% combine the two populations
rate = [rate rate2];

%% Syanptic currents

% Post-synaptic current. This current (multiplied by the synaptic weight)
% is initiated each time a spike arrives. It rises quickly and falls
% slowly.
psc = exp(-1/tau*(0:dt:.100));

% Set the peak current for each synapse in the two populations
%   Population 1
peakCurrent  = synapseFunc(numSynapses/2);
%   Population 2
peakCurrent2 = synapseFunc2(numSynapses/2);

% Combine the two populations
peakCurrent = [peakCurrent(:); peakCurrent2(:)]';

%% Generate spikes 

% % We could use a true Poisson process (slow)
% spikes = poissrnd(rate);

% ... or an approximation (faster)
tmp = rand(size(rate)); spikes = zeros(size(tmp));
spikes(tmp < rate) = 1;


%% Generate currents
% multiply each spike by the peak current of the appropriate synapse
spikes = bsxfun(@times, spikes, peakCurrent);

% sum over synapses
spikes = sum(spikes,2);

% convolve spikes with post synaptic current
Q = conv(spikes, psc, 'full'); Q = Q(1:nt);

% Initialize the dendritic current
I = zeros(1, nt); 

%% Leaky integration ********************
% This is the key computational step. ***

% We calculate the stepwise change in current because the decay is
% proportional to the current level (described by a differential
% equation)
for jj = 1:length(Q)-1
    
    % rate of change in current
    dIdt = (Q(jj) - I(jj)) / alpha;
    
    % stepwise change in current
    dI = dIdt * dt;
    
    % current at next time point
    I(jj+1) = I(jj) + dI;
end

% keep only time points with t > 0. time points less than zero indicate a
% 'pre-conditioning' that is presumably used to let the system settle.

if min(t) < 0, 
    inds = t>0;
    t = t(inds);
    I = I(inds);
end

% If no outputs, then plot
if nargout == 0, figure(1); plot(t, I); end

return